\documentclass[11pt]{article}

\usepackage[portuguese]{babel}
\usepackage[utf8]{inputenc}
\usepackage{amsmath}
\usepackage{graphicx}
\usepackage{float}
\usepackage{subfig}
\usepackage{fixltx2e}
\usepackage[bottom]{footmisc}
\usepackage{color}
\usepackage{todonotes}
% \usepackage[usenames,dvipsnames]{xcolor}
\usepackage[font=footnotesize]{caption}
\numberwithin{equation}{section}

\linespread{1.3}
\usepackage{indentfirst}
\usepackage[top=2cm, bottom=2cm, right=2.5cm, left=2.5cm]{geometry}
\addto\captionsportuguese{\renewcommand{\contentsname}{Índice}}

\begin{document}

\begin{titlepage}
\begin{center}

\hfill \break
\hfill \break

\includegraphics[width=0.3\textwidth]{./logo}~\\[1cm]

\textsc{\LARGE Instituto Superior Técnico}\\[0.25cm]
\textsc{\Large Mestrado Integrado em Engenharia Electrotécnica e de Computadores}\\[1.8cm]
\textsc{\huge Arquitecturas Avançadas de Computadores}\\[0.25cm]

{\huge \bfseries Simulação de um processador $\mu$Risc\\[1.2cm]}

\begin{tabular}{ l l }
Maria Margarida Dias dos Reis & \hspace{2mm} n.º 73099 \\
Nuno Miguel Rodrigues Machado & \hspace{2mm} n.º 74236 
\end{tabular}

\vfill

{\large Lisboa, 29 de Março 2014} 

\end{center}
\end{titlepage}

\pagenumbering{gobble}
\clearpage

\tableofcontents
\pagebreak

\clearpage
\pagenumbering{arabic}

\section{Introdução}

Com este trabalho laboratorial pretende-se projectar um processador $\mu$Risc, de 16 \textit{bits} com arquitectura RISC. O processador possui 8 registos de uso geral e 42 instruções. O projecto do processador é feito com recurso a uma linguagem de descrição de \textit{hardware} - VHDL.

\section{Características do Processador}

O processador elaborado foi simulado para uma placa Artix 7 e tem as seguintes características:

\vspace{-2mm}

\begin{itemize}
  \item 16 \textit{bits};
  \vspace{-2.5mm}
  \item 8 registos de uso geral de 16 \textit{bits} de largura (R0, \ldots, R7);
  \vspace{-2.5mm}
  \item 42 instruções;
  \vspace{-2.5mm}
  \item instruções de 3 operandos;
  \vspace{-2.5mm}
  \item organização de dados na memória do tipo \textit{big endian};
  \vspace{-2.5mm}
  \item uma memória ROM de 8 KBytes (4k endereços $\times$ 2 \textit{bytes}) endereçada com palavras de 12 \textit{bits} utilizada para as instruções/programa e uma memória RAM de 8 KBytes (4k endereços $\times$ 2 \textit{bytes}) endereçada com palavras de 12 \textit{bits} para os dados.
  
\end{itemize}

\section{Estrutura do Processador}

O processador $\mu$Risc que foi projectado encontra-se dividido em quatro andares - num primeiro andar é feito o \textit{instruction fetch} (IF), no segundo andar é feito o \textit{instruction decode} (ID) e o \textit{operand fetch} (OF), no terceiro andar são executadas operações da ALU (EX) e de acesso à memória de dados (MEM) e, por fim, no quarto e último andar é feita a escrita no banco de registos, o \textit{write back} (WB).

\subsection{Primeiro Andar - IF}

No primeiro andar obtem-se a instrução a ser executada a cada ciclo. Como todas as instruções do programa são armazenadas na memória ROM, o \textit{instruction fetch} (IF) tem a função de endereçar a ROM com o \textit{program counter} e ler a instrução desse endereço.

FIGURA 1

O \textit{instruction fetch} (IF) é simplesmente um somador, que em cada ciclo soma $1$ ao endereço actual, e armazena o resultado no registo  \textit{PC}, como se pode ver na figura 1. O endereço actual além de ser um operando do somador também endereça a memória ROM.

Existe duas situações que altera o funcionamento sequencial do \textit{instruction fetch} (IF), a primeira ocorre quando há uma transfêrencia de controlo do tipo condicional ou incondicional, selecionando o \textit{Destino\_cond} no \textit{MUX\_1} e o resultado do somador no \textit{MUX\_2}, ou seja, \textit{S\_cond} $=1$ e \textit{S\_jump} $=0$. A ultima situação o corre quando existe uma transferência de controlo do tipo \textit{Jump and Link} ou \textit{Jump Registor}, selecionando o \textit{Destino\_jump} no \textit{MUX\_2}, ou seja, \textit{S\_jump} $=1$.


\subsection{Segundo Andar - ID e OF}
\subsection{Terceiro Andar - EX e MEM}

Neste andar trata-se de executar operações da ALU bem com operações da memória, sendo que, ao contrário do MIPS, em que é possível utilizar a ALU e a memória na mesma instrução, no processador $\mu$Risc projectado tal não é possível.

\todo{ALU}

Relativamente às operações de memória é necessário tratar de \textit{loads} e \textit{stores}. Em ambos os casos o endereçamento à RAM é feito com o valor guardado no registo A, especificado pelos \textit{bits} 3 a 5 da instrução. Para o caso de um \textit{load} o valor que estiver nessa posição de memória é guardado no registo WC, especificado pelo \textit{bits} 11 a 13 da instrução, estando o \textit{write enable} da RAM a \textit{low}. Para o caso de um \textit{store} pretende-se escrever o conteúdo do registo B, especificado pelos \textit{bits} 0 a 2 da instrução, na posição de memória anteriormente endereçada, sendo necessário colocar o \textit{write enable} da RAM a \textit{high}. 

Uma vez que o conteúdo dos registos é de 16 \textit{bits}, para endereçar a memória RAM recorre-se apenas ao 12 menos significativos. O sinal de \textit{write enable} da RAM é, como já se viu, calculado no andar anterior, mas só neste terceiro andar é que é ligado à RAM. Optou-se por fazer desta maneira para \todo{explicar a ideia de que foi para ser mais simples blah blah}

\subsection{Quarto Andar - WB}

No último andar os diversos resultados possíveis são escritos no banco de registos - pode ser o resultado de uma operação da ALU, o resultado de uma operação sobre a memória (\textit{load}), o carregamento de uma constante ou guardar em R7 o valor do próximo \textit{program counter}. Como se pode ver na figura seguinte, a seleção de qual os resultados deve ser escrito é feita com recurso a um MUX 4:1. 

FIGURA

Uma vez seleccionado o resultado a escrever é preciso escolher qual o registo onde se pretende escrever esse mesmo resultado, o registo WC. 

Para instruções da ALU a escolha do registo onde se quer escrever o resultado final é feita com recurso aos \textit{bits} 11 a 13 da instrução, assim como para operações de carregamento de constantes. Porém, para operações de transferência de controlo esses mesmos \textit{bits} representam a operação a realizar, pelo que não basta utilizar os 3 \textit{bits} referidos anteriormente para controlar um \textit{decoder} que colocasse a \textit{high} um dos 7 \textit{enables} (que estão armazenados nos 7 \textit{bits} de um vector), tal como pensado originalmente e como pode ser visto na figura abaixo.

FIGURA

No entanto, a solução acima tem um problema - suponha-se o caso da instrução 1401 (HEX) que corresponde a um \textit{jump if true} mediante a condição do resultado da ALU ser negativo. Os \textit{bits} 11 a 13 da instrução são 010 e, como tal, o \textit{enable} do registo R2 ficaria activo. Porém, não se pretende escrever nesse registo. O mesmo decorre para uma operação de \textit{store} na RAM e NOP. 

Assim, para resolver o problema é necessário criar um sinal que faça \textit{override} ao \textit{enable} que o \textit{decoder} colocou a \textit{high}, permitindo o sinal de \textit{override} colocar o \textit{enable} a \textit{low}, tal como pretendido, para que não se escreva em nenhum registo.

O sinal de \textit{override} é obtido com recurso à seguinte lógica.

FIGURA

Como se pode ver, para o caso de operações da ALU, operações de \textit{load}, carregamento de constantes e o caso de \textit{jump and link}, o sinal de \textit{override} fica a \textit{high}. Para o caso de \textit{store} na memória, transferências de controlo que não \textit{jump and link} e NOP, o sinal de \textit{override} fica a \textit{low}, tal como pretendido. De notar também que a escrita nos registos é feita no flanco positivo do relógio. 

Na figura abaixo encontra-se o esquema completo do andar de \textit{write back}.

\pagebreak

\listoftodos

\end{document}